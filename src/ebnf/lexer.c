
/*
 * Automatically generated by lexi version 2.0
 * Copyright terms for the input source also apply to this generated code.
 */

#include <assert.h>
#include <string.h>

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ - 0L) >= 199901L
#include <stdbool.h>
#include <stdint.h>
#endif



	#include <assert.h>
	#include <stdio.h>
	#include <stdlib.h>

	#include "../io.h"
	#include "../tokens.h"
	#include "../xalloc.h"

	#include "lexer.h"

	/*
	 * Interfaces for the generated lexer.
	 */

	typedef enum tok ZTTERMINAL;


	FILE *io_fin;
	unsigned int io_line;

	char io_buffer[1024];

	size_t bufferindex;


	/*
	 * Lexi's interface to get a character from our input stream.
	 */
	static int
	lexi_getchar(struct bnf_state *state)
	{
		int c;

		assert(state != NULL);

		(void) state;

		c = getc(io_fin);
		if (c == EOF) {
			return EOF;
		}

		if (c == '\n') {
			io_line++;
		}

		return c;
	}

int ebnf_readchar(struct ebnf_state *state) {
	if (state->buffer_index) {
		return ebnf_pop(state);
	}

	return lexi_getchar(state);
}
void ebnf_push(struct ebnf_state *state, const int c) {
	assert(state);
	assert((size_t) state->buffer_index < sizeof state->buffer / sizeof *state->buffer);
	state->buffer[state->buffer_index++] = c;
}

int ebnf_pop(struct ebnf_state *state) {
	assert(state);
	assert(state->buffer_index > 0);
	return state->buffer[--state->buffer_index];
}

void ebnf_flush(struct ebnf_state *state) {
	state->buffer_index = 0;
}


/* LOOKUP TABLE */

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ - 0L) >= 199901L
typedef uint8_t lookup_type;
#else
typedef unsigned char lookup_type;
#endif
static lookup_type lookup_tab[] = {
	   0,    0,    0,    0,    0,    0,    0,    0,    0, 0x21, 0x21, 0x21, 
	0x21, 0x21,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0, 0x22,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,  0x6,    0,    0, 
	 0xe,  0xe,  0xe,  0xe,  0xe,  0xe,  0xe,  0xe,  0xe,  0xe,    0,    0, 
	   0,    0,    0,    0,    0, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
	0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
	0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,    0,    0,    0,    0,  0x6, 
	   0, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
	0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 
	0x16, 0x16, 0x16,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0
};

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ - 0L) >= 199901L
bool ebnf_group(enum ebnf_groups group, int c) {
#else
int ebnf_group(enum ebnf_groups group, int c) {
#endif
	if (c == LEXI_EOF) {
		return 0;
	}
	return lookup_tab[c] & group;
}


/* PRE-PASS ANALYSERS */

void ebnf_init(struct ebnf_state *state) {
	state->zone = ebnf_next;
	state->buffer_index = 0;
}
/* ZONES PASS ANALYSER PROTOTYPES */

static int ebnf_next_number(struct ebnf_state *state);
static int ebnf_next_name(struct ebnf_state *state);
static int ebnf_next_double(struct ebnf_state *state);
static int ebnf_next_single(struct ebnf_state *state);
static void ebnf_next_comment(struct ebnf_state *state);
/* MAIN PASS ANALYSERS */


/* MAIN PASS ANALYSER for number */
static int
ebnf_next_number(struct ebnf_state *state)
{
	start: {
		int c0 = ebnf_readchar(state);
		if (c0 == LEXI_EOF) {
			/* ACTION <err_unexpected_eof> */
			{

	xerror("unexpected EOF on line %d", io_line);
			}
			/* END ACTION <err_unexpected_eof> */
			goto start; /* leaf */
		}
		if (ebnf_group(ebnf_group_digit, c0)) {
			/* ACTION <io_push> */
			{

	io_push(c0);
			}
			/* END ACTION <io_push> */
			goto start; /* leaf */
		} else if (!ebnf_group(ebnf_group_digit, c0)) {
			ebnf_push(state, c0);
			return TOK_NUMBER;
		}

		/* DEFAULT */
		/* ACTION <err_unexpected_character> */
		{

	xerror("unexpected character \"%c\" on line %d", c0, io_line);
		}
		/* END ACTION <err_unexpected_character> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for name */
static int
ebnf_next_name(struct ebnf_state *state)
{
	start: {
		int c0 = ebnf_readchar(state);
		if (ebnf_group(ebnf_name_white, c0)) goto start;
		if (c0 == LEXI_EOF) {
			/* ACTION <err_unexpected_eof> */
			{

	xerror("unexpected EOF on line %d", io_line);
			}
			/* END ACTION <err_unexpected_eof> */
			goto start; /* leaf */
		}
		if (ebnf_group(ebnf_group_character_or_space, c0)) {
			/* ACTION <io_push> */
			{

	io_push(c0);
			}
			/* END ACTION <io_push> */
			goto start; /* leaf */
		} else if (!ebnf_group(ebnf_group_character_or_space, c0)) {
			ebnf_push(state, c0);
			return TOK_NAME;
		}

		/* DEFAULT */
		/* ACTION <err_unexpected_character> */
		{

	xerror("unexpected character \"%c\" on line %d", c0, io_line);
		}
		/* END ACTION <err_unexpected_character> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for double */
static int
ebnf_next_double(struct ebnf_state *state)
{
	start: {
		int c0 = ebnf_readchar(state);
		switch (c0) {
		case LEXI_EOF: {
				/* ACTION <err_unexpected_eof> */
				{

	xerror("unexpected EOF on line %d", io_line);
				}
				/* END ACTION <err_unexpected_eof> */
				goto start; /* leaf */
			}

		case '"': {
				/* ACTION <io_literal> */
				{
					ZTTERMINAL ZT1;

	ZT1 = io_literal();
					return ZT1;
				}
				/* END ACTION <io_literal> */
			}

		}

		/* DEFAULT */
		/* ACTION <io_push> */
		{

	io_push(c0);
		}
		/* END ACTION <io_push> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for single */
static int
ebnf_next_single(struct ebnf_state *state)
{
	start: {
		int c0 = ebnf_readchar(state);
		switch (c0) {
		case LEXI_EOF: {
				/* ACTION <err_unexpected_eof> */
				{

	xerror("unexpected EOF on line %d", io_line);
				}
				/* END ACTION <err_unexpected_eof> */
				goto start; /* leaf */
			}

		case '`': {
				/* ACTION <io_literal> */
				{
					ZTTERMINAL ZT1;

	ZT1 = io_literal();
					return ZT1;
				}
				/* END ACTION <io_literal> */
			}

		}

		/* DEFAULT */
		/* ACTION <io_push> */
		{

	io_push(c0);
		}
		/* END ACTION <io_push> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for comment */
static void
ebnf_next_comment(struct ebnf_state *state)
{
	start: {
		int c0 = ebnf_readchar(state);
		switch (c0) {
		case LEXI_EOF: {
				/* ACTION <err_unexpected_eof> */
				{

	xerror("unexpected EOF on line %d", io_line);
				}
				/* END ACTION <err_unexpected_eof> */
				goto start; /* leaf */
			}

		case '*': {
				int c1 = ebnf_readchar(state);
				if (c1 == ')') {
					return;
				}
				ebnf_push(state, c1);
			}
			break;

		}

		/* DEFAULT */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for global zone */
int
ebnf_next(struct ebnf_state *state)
{
	if (state->zone != ebnf_next)
		return state->zone(state);
	start: {
		int c0 = ebnf_readchar(state);
		if (ebnf_group(ebnf_group_white, c0)) goto start;
		switch (c0) {
		case '?': {
				return TOK_OPT;
			}

		case '*': {
				return TOK_STAR;
			}

		case '-': {
				return TOK_EXCEPT;
			}

		case ')': {
				return TOK_END_HGROUP;
			}

		case '=': {
				return TOK_EQUALS;
			}

		case ',': {
				return TOK_CAT;
			}

		case ':': {
				int c1 = ebnf_readchar(state);
				if (c1 == ')') {
					return TOK_END_HSTAR;
				}
				ebnf_push(state, c1);
			}
			break;

		case '.': {
				return TOK_SEP;
			}

		case '!': {
				return TOK_ALT;
			}

		case '/': {
				int c1 = ebnf_readchar(state);
				if (c1 == ')') {
					return TOK_END_HOPT;
				}
				ebnf_push(state, c1);
				return TOK_ALT;
			}

		case ';': {
				return TOK_SEP;
			}

		case '}': {
				return TOK_END_HSTAR;
			}

		case '{': {
				return TOK_START_HSTAR;
			}

		case ']': {
				return TOK_END_HOPT;
			}

		case '[': {
				return TOK_START_HOPT;
			}

		case '|': {
				return TOK_ALT;
			}

		case '"': {
				return ebnf_next_double(state);
			}

		case '`': {
				return ebnf_next_single(state);
			}

		case '(': {
				int c1 = ebnf_readchar(state);
				switch (c1) {
				case '/': {
						int c2 = ebnf_readchar(state);
						if (c2 == ')') {
							/* ACTION <err_invalid_sequence> */
							{

	xerror("invalid character sequence \"%c%c%c\" on line %d", c0, c1, c2, io_line);
							}
							/* END ACTION <err_invalid_sequence> */
							goto start; /* leaf */
						}
						ebnf_push(state, c2);
						return TOK_START_HOPT;
					}

				case ':': {
						int c2 = ebnf_readchar(state);
						if (c2 == ')') {
							/* ACTION <err_invalid_sequence> */
							{

	xerror("invalid character sequence \"%c%c%c\" on line %d", c0, c1, c2, io_line);
							}
							/* END ACTION <err_invalid_sequence> */
							goto start; /* leaf */
						}
						ebnf_push(state, c2);
						return TOK_START_HSTAR;
					}

				case '*': {
						int c2 = ebnf_readchar(state);
						if (c2 == ')') {
							/* ACTION <err_invalid_sequence> */
							{

	xerror("invalid character sequence \"%c%c%c\" on line %d", c0, c1, c2, io_line);
							}
							/* END ACTION <err_invalid_sequence> */
							goto start; /* leaf */
						}
						ebnf_push(state, c2);
						ebnf_next_comment(state);
						goto start;	/* pure function */
					}

				}
				ebnf_push(state, c1);
				return TOK_START_HGROUP;
			}

		case LEXI_EOF: {
				return TOK_SEP;
			}

		}
		if (ebnf_group(ebnf_group_digit, c0)) {
			/* ACTION <io_push> */
			{

	io_push(c0);
			}
			/* END ACTION <io_push> */
			return ebnf_next_number(state);
		} else if (ebnf_group(ebnf_group_character, c0)) {
			/* ACTION <io_push> */
			{

	io_push(c0);
			}
			/* END ACTION <io_push> */
			return ebnf_next_name(state);
		}

		/* DEFAULT */
		/* ACTION <err_unexpected_character> */
		{

	xerror("unexpected character \"%c\" on line %d", c0, io_line);
		}
		/* END ACTION <err_unexpected_character> */
		goto start; /* DEFAULT */
	}
}



