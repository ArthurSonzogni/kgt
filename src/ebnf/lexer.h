/* Generated by lx */

#ifndef LX_H
#define LX_H

enum lx_ebnf_token {
	TOK_COUNT,
	TOK_IDENT,
	TOK_STAR,
	TOK_EXCEPT,
	TOK_ENDGROUP,
	TOK_STARTGROUP,
	TOK_EQUALS,
	TOK_CAT,
	TOK_ENDSTAR,
	TOK_STARTSTAR,
	TOK_ENDOPT,
	TOK_STARTOPT,
	TOK_SEP,
	TOK_ALT,
	TOK_LITERAL,
	TOK_CHAR,
	TOK_EOF,
	TOK_ERROR,
	TOK_UNKNOWN
};

struct lx_pos {
	unsigned byte;
	unsigned line;
	unsigned col;
};

struct lx_ebnf_lx {
	int (*lgetc)(struct lx_ebnf_lx *lx);
	void *opaque;

	int c; /* lx_ebnf_ungetc buffer */

	struct lx_pos start;
	struct lx_pos end;

	void *buf;
	int  (*push) (struct lx_ebnf_lx *lx, char c);
	void (*pop)  (struct lx_ebnf_lx *lx);
	int  (*clear)(struct lx_ebnf_lx *lx);
	void (*free) (struct lx_ebnf_lx *lx);

	enum lx_ebnf_token (*z)(struct lx_ebnf_lx *lx);
};

/*
 * The initial buffer size; this ought to be over the typical token length,
 * so as to avoid a run-up of lots of resizing.
 */
#ifndef LX_DYN_LOW
#define LX_DYN_LOW 1 << 10
#endif

/*
 * High watermark; if the buffer grows over this, it will resize back down
 * by LX_DYN_FACTOR when no longer in use.
 */
#ifndef LX_DYN_HIGH
#define LX_DYN_HIGH 1 << 13
#endif

/*
 * Andrew Koenig said the growth factor should be less than phi, (1 + sqrt(5)) / 2
 * P.J. Plauger said 1.5 works well in practice. (Perhaps because of internal
 * bookkeeping data stored by the allocator.)
 *
 * Non-integer factors here add the constraint that LX_DYN_LOW > 1 because
 * because conversion to size_t truncates, and e.g. 1 * 1.5 == 1 is no good
 * as the requirement is to *increase* a buffer.
 */
#ifndef LX_DYN_FACTOR
#define LX_DYN_FACTOR 2
#endif

/* dynamic token buffer */
struct lx_dynbuf {
	char *p;
	size_t len;
	char *a;
};

/* fixed-size token buffer */
struct lx_fixedbuf {
	char *p;
	size_t len;
#ifdef LX_FIXED_SIZE
	char a[LX_FIXED_SIZE];
#else
	char *a; /* could be flexible member */
#endif
};

/* opaque for lx_ebnf_agetc */
struct lx_arr {
	char *p;
	size_t len;
};

/* opaque for lx_ebnf_fdgetc */
struct lx_fd {
	char *p;
	size_t len;

	int fd;
	size_t bufsz; /* number of bytes allocated after this struct */
};

const char *lx_ebnf_name(enum lx_ebnf_token t);
const char *lx_ebnf_example(enum lx_ebnf_token (*z)(struct lx_ebnf_lx *), enum lx_ebnf_token t);

void lx_ebnf_init(struct lx_ebnf_lx *lx);
enum lx_ebnf_token lx_ebnf_next(struct lx_ebnf_lx *lx);

int lx_ebnf_fgetc(struct lx_ebnf_lx *lx);
int lx_ebnf_sgetc(struct lx_ebnf_lx *lx);
int lx_ebnf_agetc(struct lx_ebnf_lx *lx);
int lx_ebnf_dgetc(struct lx_ebnf_lx *lx);

int  lx_ebnf_dynpush(struct lx_ebnf_lx *lx, char c);
void lx_ebnf_dynpop(struct lx_ebnf_lx *lx);
int  lx_ebnf_dynclear(struct lx_ebnf_lx *lx);
void lx_ebnf_dynfree(struct lx_ebnf_lx *lx);

int  lx_ebnf_fixedpush(struct lx_ebnf_lx *lx, char c);
void lx_ebnf_fixedpop(struct lx_ebnf_lx *lx);
int  lx_ebnf_fixedclear(struct lx_ebnf_lx *lx);

#endif

