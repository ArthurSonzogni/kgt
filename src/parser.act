/* $Id$ */

/*
 * Shared parser actions
 */

%prefixes%

	terminal = TOK_;
	function = prod_;

%maps%

	string -> map_string;
	number -> map_number;

	ast_term       -> map_term;
	ast_alt        -> map_alt;
	ast_production -> map_production;

%header% @{

	#include <stdlib.h>
	#include <string.h>
	#include <assert.h>
	#include <ctype.h>

	#include "../io.h"
	#include "../ast.h"
	#include "../tokens.h"
	#include "../xalloc.h"

	/* See main.c */
	extern int act_currenttoken;
	extern int act_next(void);

	int act_savedtoken;

	/* Interfaces required by SID's generated parser */
	#define ERROR_TERMINAL   @$ERROR
	#define CURRENT_TERMINAL act_currenttoken
	#define ADVANCE_LEXER    do { act_currenttoken = act_next(); } while (0)
	#define SAVE_LEXER(t)    do { act_savedtoken = act_currenttoken; act_currenttoken = (t); } while (0)
	#define RESTORE_LEXER    do { act_currenttoken = act_savedtoken; } while (0)

	/* See %maps% */
	typedef const char * map_string;
	typedef unsigned int map_number;

	typedef struct ast_term * map_term;
	typedef struct ast_alt * map_alt;
	typedef struct ast_production * map_production;

	static void
	expected(const char *msg)
	{
		if (msg == NULL) {
			xerror("syntax error on line %u", io_line);
		} else {
			xerror("syntax error on line %u: expected %s", io_line, msg);
		}
	}

	static void
	rtrim(char *s)
	{
		char *p = s + strlen(s) - 1;

		assert(strlen(s) > 0);

		while (p >= s && isspace((unsigned char) *p)) {
			*p-- = '\0';
		}
	}

@}, @{

	int act_next(void);

@};

%assignments%

%parameter-assignments%

%result-assignments%

%terminals%

	NAME: () -> (s :string) = @{
		assert(strlen(io_buffer) > 0);
		assert(!isspace((unsigned char) io_buffer[0]));
		rtrim(io_buffer);
		@s = xstrdup(io_buffer);
		io_flush();
	@};

	LITERAL: () -> (s :string) = @{
		assert(strlen(io_buffer) > 0);
		@s = xstrdup(io_buffer);
		io_flush();
	@};

	NUMBER: () -> (n :number) = @{
		assert(strlen(io_buffer) > 0);

		if (strlen(io_buffer) > 5) {
			xerror("numeric literals may be 5 digits maximum");
		}

		@n = atoi(io_buffer);
		io_flush();
	@};

%actions%

	/* TODO: big pile of error messages */


	<make-empty-term>: () -> (t :ast_term) = @{
		@t = xmalloc(sizeof *@t);
		@t->type = TYPE_EMPTY;
		@t->repeat = 1;
		@t->next = NULL;
	@};

	<make-literal-term>: (l :string) -> (t :ast_term) = @{
		@t = xmalloc(sizeof *@t);
		@t->type = TYPE_TERMINAL;	/* TODO rename to literal or vice-versa, perhaps */
		@t->u.literal = @l;
		@t->repeat = 1;
		@t->next = NULL;
	@};

	<make-production-term>: (n :string) -> (t :ast_term) = @{
		@t = xmalloc(sizeof *@t);
		@t->type = TYPE_PRODUCTION;
		@t->u.name = @n;
		@t->repeat = 1;
		@t->next = NULL;
	@};

	<make-alt>: (t :ast_term) -> (a :ast_alt) = @{
		@a = xmalloc(sizeof *@a);
		@a->terms = @t;
		@a->next = NULL;
	@};

	<make-production>: (n :string, a :ast_alt) -> (p :ast_production) = @{
		@p = xmalloc(sizeof *@p);
		@p->name = @n;
		@p->alts = @a;
		@p->next = NULL;
	@};

	<make-empty-production>: () -> (p :ast_production) = @{
		@p = NULL;
	@};


	<make-star-group>: (a :ast_alt) -> (t :ast_term) = @{
		@t = xmalloc(sizeof *@t);
		@t->type = TYPE_GROUP;
		@t->u.group = xmalloc(sizeof *@t->u.group);
		@t->u.group->kleene = KLEENE_STAR;
		@t->u.group->alts = @a;
	@};

	<make-opt-group>: (a :ast_alt) -> (t :ast_term) = @{
		@t = xmalloc(sizeof *@t);
		@t->type = TYPE_GROUP;
		@t->u.group = xmalloc(sizeof *@t->u.group);
		@t->u.group->kleene = KLEENE_OPTIONAL;
		@t->u.group->alts = @a;
	@};

	<make-alt-group>: (a :ast_alt) -> (t :ast_term) = @{
		@t = xmalloc(sizeof *@t);
		@t->type = TYPE_GROUP;
		@t->u.group = xmalloc(sizeof *@t->u.group);
		@t->u.group->kleene = KLEENE_GROUP;
		@t->u.group->alts = @a;
	@};


	<set-repeat>: (t :ast_term, n :number) -> () = @{
		assert(@n > 0);
		@t->repeat = @n;
	@};


	<add-term-to-list>: (l :ast_term, t :ast_term) -> () = @{
		assert(@t->next == NULL);
		@t->next = @l;
	@};

	<add-alt-to-list>: (l :ast_alt, a :ast_alt) -> () = @{
		assert(@a->next == NULL);
		@a->next = @l;
	@};

	<add-production-to-list>: (l :ast_production, p :ast_production) -> () = @{
		assert(@p->next == NULL);
		@p->next = @l;
	@};


	<err-expected-alt> = @{
		expected("alternative separator");
	@};

	<err-expected-sep> = @{
		expected("alternative separator");
	@};

	<err-expected-equals> = @{
		expected("production assignment");
	@};

	<err-unhandled> = @{
		expected(NULL);
	@};

%trailer% @{
@}, @{
@};

