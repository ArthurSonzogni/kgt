/* Generated by lx */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

#include <unistd.h>
#include <fcntl.h>

#include LX_HEADER

static enum lx_abnf_token z1(struct lx_abnf_lx *lx);
static enum lx_abnf_token z2(struct lx_abnf_lx *lx);
static enum lx_abnf_token z3(struct lx_abnf_lx *lx);
static enum lx_abnf_token z4(struct lx_abnf_lx *lx);

static int
lx_getc(struct lx_abnf_lx *lx)
{
	int c;

	assert(lx != NULL);
	assert(lx->lgetc != NULL);

	if (lx->c != EOF) {
		c = lx->c, lx->c = EOF;
	} else {
		c = lx->lgetc(lx);
		if (c == EOF) {
			return EOF;
		}
	}

	lx->end.byte++;
	lx->end.col++;

	if (c == '\n') {
		lx->end.line++;
		lx->end.col = 1;
	}

	return c;
}

static void
lx_abnf_ungetc(struct lx_abnf_lx *lx, int c)
{
	assert(lx != NULL);
	assert(lx->c == EOF);

	lx->c = c;

	if (lx->pop != NULL) {
		lx->pop(lx);
	}

	lx->end.byte--;
	lx->end.col--;

	if (c == '\n') {
		lx->end.line--;
		lx->end.col = 0; /* XXX: lost information */
	}
}

int
lx_abnf_fgetc(struct lx_abnf_lx *lx)
{
	assert(lx != NULL);
	assert(lx->opaque != NULL);

	return fgetc(lx->opaque);
}

int
lx_abnf_sgetc(struct lx_abnf_lx *lx)
{
	char *s;

	assert(lx != NULL);
	assert(lx->opaque != NULL);

	s = lx->opaque;
	if (*s == '\0') {
		return EOF;
	}

	return lx->opaque = s + 1, *s;
}

int
lx_abnf_agetc(struct lx_abnf_lx *lx)
{
	struct lx_arr *a;

	assert(lx != NULL);
	assert(lx->opaque != NULL);

	a = lx->opaque;

	assert(a != NULL);
	assert(a->p != NULL);

	if (a->len == 0) {
		return EOF;
	}

	return a->len--, *a->p++;
}

int
lx_abnf_dgetc(struct lx_abnf_lx *lx)
{
	struct lx_fd *d;

	assert(lx != NULL);
	assert(lx->opaque != NULL);

	d = lx->opaque;
	assert(d->fd != -1);
	assert(d->p != NULL);

	if (d->len == 0) {
		ssize_t r;

		assert((fcntl(d->fd, F_GETFL) & O_NONBLOCK) == 0);

		d->p = (char *) d + sizeof *d;

		r = read(d->fd, d->p, d->bufsz);
		if (r == -1) {
			assert(errno != EAGAIN);
			return EOF;
		}

		if (r == 0) {
			return EOF;
		}

		d->len = r;
	}

	return d->len--, *d->p++;
}

int
lx_abnf_dynpush(struct lx_abnf_lx *lx, char c)
{
	struct lx_dynbuf *t;

	assert(lx != NULL);
	assert(c != EOF);

	t = lx->buf;

	assert(t != NULL);

	if (t->p == t->a + t->len) {
		size_t len;
		char *tmp;

		if (t->len == 0) {
			assert(LX_DYN_LOW > 0);
			len = LX_DYN_LOW;
		} else {
			len = t->len * LX_DYN_FACTOR;
			if (len < t->len) {
				errno = ERANGE;
				return -1;
			}
		}

		tmp = realloc(t->a, len);
		if (tmp == NULL) {
			return -1;
		}

		t->p   = tmp + (t->p - t->a);
		t->a   = tmp;
		t->len = len;
	}

	assert(t->p != NULL);
	assert(t->a != NULL);

	*t->p++ = c;

	return 0;
}

void
lx_abnf_dynpop(struct lx_abnf_lx *lx)
{
	struct lx_dynbuf *t;

	assert(lx != NULL);

	t = lx->buf;

	assert(t != NULL);
	assert(t->a != NULL);
	assert(t->p >= t->a);

	if (t->p == t->a) {
		return;
	}

	t->p--;
}

int
lx_abnf_dynclear(struct lx_abnf_lx *lx)
{
	struct lx_dynbuf *t;

	assert(lx != NULL);

	t = lx->buf;

	assert(t != NULL);

	if (t->len > LX_DYN_HIGH) {
		size_t len;
		char *tmp;

		len = t->len / LX_DYN_FACTOR;

		tmp = realloc(t->a, len);
		if (tmp == NULL) {
			return -1;
		}

		t->a   = tmp;
		t->len = len;
	}

	t->p = t->a;

	return 0;
}

void
lx_abnf_dynfree(struct lx_abnf_lx *lx)
{
	struct lx_dynbuf *t;

	assert(lx != NULL);

	t = lx->buf;

	assert(t != NULL);

	free(t->a);
}
int
lx_abnf_fixedpush(struct lx_abnf_lx *lx, char c)
{
	struct lx_fixedbuf *t;

	assert(lx != NULL);
	assert(c != EOF);

	t = lx->buf;

	assert(t != NULL);
	assert(t->p != NULL);
	assert(t->a != NULL);

	if (t->p == t->a + t->len) {
		errno = ENOMEM;
		return -1;
	}

	*t->p++ = c;

	return 0;
}

void
lx_abnf_fixedpop(struct lx_abnf_lx *lx)
{
	struct lx_fixedbuf *t;

	assert(lx != NULL);

	t = lx->buf;

	assert(t != NULL);
	assert(t->a != NULL);
	assert(t->p >= t->a);

	if (t->p == t->a) {
		return;
	}

	t->p--;
}

int
lx_abnf_fixedclear(struct lx_abnf_lx *lx)
{
	struct lx_fixedbuf *t;

	assert(lx != NULL);

	t = lx->buf;

	assert(t != NULL);
	assert(t->p != NULL);
	assert(t->a != NULL);

	t->p = t->a;

	return 0;
}

static enum lx_abnf_token
z1(struct lx_abnf_lx *lx)
{
	int c;

	enum {
		S1, S2, S3
	} state;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx);
	}

	state = S3;

	lx->start = lx->end;

	while (c = lx_getc(lx), c != EOF) {
		switch (state) {
			break;

		default:
			if (lx->push != NULL) {
				if (-1 == lx->push(lx, c)) {
					return TOK_ERROR;
				}
			}
			break;

		}

		switch (state) {
		case S1: /* e.g. "\"" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z = z4, TOK_LITERAL;
			}

		case S2: /* e.g. "a" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_CHAR;
			}

		case S3: /* start */
			switch (c) {
			case '\"': state = S1;      continue;
			default:  state = S2;     continue;
			}
		}
	}

	lx->lgetc = NULL;

	switch (state) {
	case S1: return TOK_LITERAL;
	case S2: return TOK_CHAR;
	default: errno = EINVAL; return TOK_ERROR;
	}
}

static enum lx_abnf_token
z2(struct lx_abnf_lx *lx)
{
	int c;

	enum {
		S1, S2, S3
	} state;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx);
	}

	state = S3;

	lx->start = lx->end;

	while (c = lx_getc(lx), c != EOF) {
		switch (state) {
			break;

		default:
			if (lx->push != NULL) {
				if (-1 == lx->push(lx, c)) {
					return TOK_ERROR;
				}
			}
			break;

		}

		switch (state) {
		case S1: /* e.g. ">" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z = z4, TOK_NAME;
			}

		case S2: /* e.g. "a" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_CHAR;
			}

		case S3: /* start */
			switch (c) {
			case '-': state = S2;      continue;
			case '0': state = S2;      continue;
			case '1': state = S2;      continue;
			case '2': state = S2;      continue;
			case '3': state = S2;      continue;
			case '4': state = S2;      continue;
			case '5': state = S2;      continue;
			case '6': state = S2;      continue;
			case '7': state = S2;      continue;
			case '8': state = S2;      continue;
			case '9': state = S2;      continue;
			case '>': state = S1;      continue;
			case 'A': state = S2;      continue;
			case 'B': state = S2;      continue;
			case 'C': state = S2;      continue;
			case 'D': state = S2;      continue;
			case 'E': state = S2;      continue;
			case 'F': state = S2;      continue;
			case 'G': state = S2;      continue;
			case 'H': state = S2;      continue;
			case 'I': state = S2;      continue;
			case 'J': state = S2;      continue;
			case 'K': state = S2;      continue;
			case 'L': state = S2;      continue;
			case 'M': state = S2;      continue;
			case 'N': state = S2;      continue;
			case 'O': state = S2;      continue;
			case 'P': state = S2;      continue;
			case 'Q': state = S2;      continue;
			case 'R': state = S2;      continue;
			case 'S': state = S2;      continue;
			case 'T': state = S2;      continue;
			case 'U': state = S2;      continue;
			case 'V': state = S2;      continue;
			case 'W': state = S2;      continue;
			case 'X': state = S2;      continue;
			case 'Y': state = S2;      continue;
			case 'Z': state = S2;      continue;
			case '_': state = S2;      continue;
			case 'a': state = S2;      continue;
			case 'b': state = S2;      continue;
			case 'c': state = S2;      continue;
			case 'd': state = S2;      continue;
			case 'e': state = S2;      continue;
			case 'f': state = S2;      continue;
			case 'g': state = S2;      continue;
			case 'h': state = S2;      continue;
			case 'i': state = S2;      continue;
			case 'j': state = S2;      continue;
			case 'k': state = S2;      continue;
			case 'l': state = S2;      continue;
			case 'm': state = S2;      continue;
			case 'n': state = S2;      continue;
			case 'o': state = S2;      continue;
			case 'p': state = S2;      continue;
			case 'q': state = S2;      continue;
			case 'r': state = S2;      continue;
			case 's': state = S2;      continue;
			case 't': state = S2;      continue;
			case 'u': state = S2;      continue;
			case 'v': state = S2;      continue;
			case 'w': state = S2;      continue;
			case 'x': state = S2;      continue;
			case 'y': state = S2;      continue;
			case 'z': state = S2;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}
		}
	}

	lx->lgetc = NULL;

	switch (state) {
	case S1: return TOK_NAME;
	case S2: return TOK_CHAR;
	default: errno = EINVAL; return TOK_ERROR;
	}
}

static enum lx_abnf_token
z3(struct lx_abnf_lx *lx)
{
	int c;

	enum {
		S1, S2, S3
	} state;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx);
	}

	state = S3;

	lx->start = lx->end;

	while (c = lx_getc(lx), c != EOF) {
		switch (state) {
		case S1:
		case S2:
		case S3:
			break;

		default:
			if (lx->push != NULL) {
				if (-1 == lx->push(lx, c)) {
					return TOK_ERROR;
				}
			}
			break;

		}

		switch (state) {
		case S1: /* e.g. "\x0a" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z = z4, lx->z(lx);
			}

		case S2: /* e.g. "a" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z(lx);
			}

		case S3: /* start */
			switch (c) {
			case '\n': state = S1;      continue;
			default:  state = S2;     continue;
			}
		}
	}

	lx->lgetc = NULL;

	switch (state) {
	case S1: return TOK_EOF;
	case S2: return TOK_EOF;
	default: errno = EINVAL; return TOK_ERROR;
	}
}

static enum lx_abnf_token
z4(struct lx_abnf_lx *lx)
{
	int c;

	enum {
		S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, 
		S11, S12, S13, S14, S15, S16, S17, S18, S19, S20, 
		S21, S22, S23, S24, S25, S26, S27, S28, S29, S30, 
		S31, S32, S33, S34, S35, S36
	} state;

	assert(lx != NULL);

	if (lx->clear != NULL) {
		lx->clear(lx);
	}

	state = S36;

	lx->start = lx->end;

	while (c = lx_getc(lx), c != EOF) {
		switch (state) {
		case S22:
		case S23:
		case S30:
		case S31:
			break;

		default:
			if (lx->push != NULL) {
				if (-1 == lx->push(lx, c)) {
					return TOK_ERROR;
				}
			}
			break;

		}

		switch (state) {
		case S1: /* e.g. "=/" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_ALTINC;
			}

		case S2: /* e.g. "%b0.0" */
			switch (c) {
			case '.': state = S5;      continue;
			case '0':	          continue;
			case '1':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_BINSTR;
			}

		case S3: /* e.g. "%b0-0" */
			switch (c) {
			case '0':	          continue;
			case '1':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_BINRANGE;
			}

		case S4: /* e.g. "%b0-" */
			switch (c) {
			case '0': state = S3;      continue;
			case '1': state = S3;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S5: /* e.g. "%b0." */
			switch (c) {
			case '0': state = S2;      continue;
			case '1': state = S2;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S6: /* e.g. "%b0" */
			switch (c) {
			case '-': state = S4;      continue;
			case '.': state = S5;      continue;
			case '0':	          continue;
			case '1':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_BINSTR;
			}

		case S7: /* e.g. "%d0.0" */
			switch (c) {
			case '.': state = S10;      continue;
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_DECSTR;
			}

		case S8: /* e.g. "%d0-0" */
			switch (c) {
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_DECRANGE;
			}

		case S9: /* e.g. "%d0-" */
			switch (c) {
			case '0': state = S8;      continue;
			case '1': state = S8;      continue;
			case '2': state = S8;      continue;
			case '3': state = S8;      continue;
			case '4': state = S8;      continue;
			case '5': state = S8;      continue;
			case '6': state = S8;      continue;
			case '7': state = S8;      continue;
			case '8': state = S8;      continue;
			case '9': state = S8;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S10: /* e.g. "%d0." */
			switch (c) {
			case '0': state = S7;      continue;
			case '1': state = S7;      continue;
			case '2': state = S7;      continue;
			case '3': state = S7;      continue;
			case '4': state = S7;      continue;
			case '5': state = S7;      continue;
			case '6': state = S7;      continue;
			case '7': state = S7;      continue;
			case '8': state = S7;      continue;
			case '9': state = S7;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S11: /* e.g. "%d0" */
			switch (c) {
			case '-': state = S9;      continue;
			case '.': state = S10;      continue;
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_DECSTR;
			}

		case S12: /* e.g. "%xa.a" */
			switch (c) {
			case '.': state = S15;      continue;
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			case 'A':	          continue;
			case 'B':	          continue;
			case 'C':	          continue;
			case 'D':	          continue;
			case 'E':	          continue;
			case 'F':	          continue;
			case 'a':	          continue;
			case 'b':	          continue;
			case 'c':	          continue;
			case 'd':	          continue;
			case 'e':	          continue;
			case 'f':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_HEXSTR;
			}

		case S13: /* e.g. "%xa-a" */
			switch (c) {
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			case 'A':	          continue;
			case 'B':	          continue;
			case 'C':	          continue;
			case 'D':	          continue;
			case 'E':	          continue;
			case 'F':	          continue;
			case 'a':	          continue;
			case 'b':	          continue;
			case 'c':	          continue;
			case 'd':	          continue;
			case 'e':	          continue;
			case 'f':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_HEXRANGE;
			}

		case S14: /* e.g. "%xa-" */
			switch (c) {
			case '0': state = S13;      continue;
			case '1': state = S13;      continue;
			case '2': state = S13;      continue;
			case '3': state = S13;      continue;
			case '4': state = S13;      continue;
			case '5': state = S13;      continue;
			case '6': state = S13;      continue;
			case '7': state = S13;      continue;
			case '8': state = S13;      continue;
			case '9': state = S13;      continue;
			case 'A': state = S13;      continue;
			case 'B': state = S13;      continue;
			case 'C': state = S13;      continue;
			case 'D': state = S13;      continue;
			case 'E': state = S13;      continue;
			case 'F': state = S13;      continue;
			case 'a': state = S13;      continue;
			case 'b': state = S13;      continue;
			case 'c': state = S13;      continue;
			case 'd': state = S13;      continue;
			case 'e': state = S13;      continue;
			case 'f': state = S13;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S15: /* e.g. "%xa." */
			switch (c) {
			case '0': state = S12;      continue;
			case '1': state = S12;      continue;
			case '2': state = S12;      continue;
			case '3': state = S12;      continue;
			case '4': state = S12;      continue;
			case '5': state = S12;      continue;
			case '6': state = S12;      continue;
			case '7': state = S12;      continue;
			case '8': state = S12;      continue;
			case '9': state = S12;      continue;
			case 'A': state = S12;      continue;
			case 'B': state = S12;      continue;
			case 'C': state = S12;      continue;
			case 'D': state = S12;      continue;
			case 'E': state = S12;      continue;
			case 'F': state = S12;      continue;
			case 'a': state = S12;      continue;
			case 'b': state = S12;      continue;
			case 'c': state = S12;      continue;
			case 'd': state = S12;      continue;
			case 'e': state = S12;      continue;
			case 'f': state = S12;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S16: /* e.g. "%xa" */
			switch (c) {
			case '-': state = S14;      continue;
			case '.': state = S15;      continue;
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			case 'A':	          continue;
			case 'B':	          continue;
			case 'C':	          continue;
			case 'D':	          continue;
			case 'E':	          continue;
			case 'F':	          continue;
			case 'a':	          continue;
			case 'b':	          continue;
			case 'c':	          continue;
			case 'd':	          continue;
			case 'e':	          continue;
			case 'f':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_HEXSTR;
			}

		case S17: /* e.g. "%x" */
			switch (c) {
			case '0': state = S16;      continue;
			case '1': state = S16;      continue;
			case '2': state = S16;      continue;
			case '3': state = S16;      continue;
			case '4': state = S16;      continue;
			case '5': state = S16;      continue;
			case '6': state = S16;      continue;
			case '7': state = S16;      continue;
			case '8': state = S16;      continue;
			case '9': state = S16;      continue;
			case 'A': state = S16;      continue;
			case 'B': state = S16;      continue;
			case 'C': state = S16;      continue;
			case 'D': state = S16;      continue;
			case 'E': state = S16;      continue;
			case 'F': state = S16;      continue;
			case 'a': state = S16;      continue;
			case 'b': state = S16;      continue;
			case 'c': state = S16;      continue;
			case 'd': state = S16;      continue;
			case 'e': state = S16;      continue;
			case 'f': state = S16;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S18: /* e.g. "%d" */
			switch (c) {
			case '0': state = S11;      continue;
			case '1': state = S11;      continue;
			case '2': state = S11;      continue;
			case '3': state = S11;      continue;
			case '4': state = S11;      continue;
			case '5': state = S11;      continue;
			case '6': state = S11;      continue;
			case '7': state = S11;      continue;
			case '8': state = S11;      continue;
			case '9': state = S11;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S19: /* e.g. "%b" */
			switch (c) {
			case '0': state = S6;      continue;
			case '1': state = S6;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S20: /* e.g. "\x0a\x0a" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_SEP;
			}

		case S21: /* e.g. "\x0a" */
			switch (c) {
			case '\n': state = S20;      continue;
			default:  lx_abnf_ungetc(lx, c); return lx->z(lx);
			}

		case S22: /* e.g. "\x09" */
			switch (c) {
			case '\t':	          continue;
			case '\v':	          continue;
			case '\f':	          continue;
			case '\r':	          continue;
			case ' ':	          continue;
			default:  lx_abnf_ungetc(lx, c); return lx->z(lx);
			}

		case S23: /* e.g. "\"" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z = z1, lx->z(lx);
			}

		case S24: /* e.g. "%" */
			switch (c) {
			case 'b': state = S19;      continue;
			case 'd': state = S18;      continue;
			case 'x': state = S17;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}

		case S25: /* e.g. "(" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_STARTGROUP;
			}

		case S26: /* e.g. ")" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_ENDGROUP;
			}

		case S27: /* e.g. "*" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_REP;
			}

		case S28: /* e.g. "/" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_ALT;
			}

		case S29: /* e.g. "0" */
			switch (c) {
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_COUNT;
			}

		case S30: /* e.g. ";" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z = z3, lx->z(lx);
			}

		case S31: /* e.g. "<" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return lx->z = z2, lx->z(lx);
			}

		case S32: /* e.g. "=" */
			switch (c) {
			case '/': state = S1;      continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_EQUALS;
			}

		case S33: /* e.g. "[" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_STARTOPT;
			}

		case S34: /* e.g. "]" */
			switch (c) {
			default:  lx_abnf_ungetc(lx, c); return TOK_ENDOPT;
			}

		case S35: /* e.g. "a" */
			switch (c) {
			case '-':	          continue;
			case '0':	          continue;
			case '1':	          continue;
			case '2':	          continue;
			case '3':	          continue;
			case '4':	          continue;
			case '5':	          continue;
			case '6':	          continue;
			case '7':	          continue;
			case '8':	          continue;
			case '9':	          continue;
			case 'A':	          continue;
			case 'B':	          continue;
			case 'C':	          continue;
			case 'D':	          continue;
			case 'E':	          continue;
			case 'F':	          continue;
			case 'G':	          continue;
			case 'H':	          continue;
			case 'I':	          continue;
			case 'J':	          continue;
			case 'K':	          continue;
			case 'L':	          continue;
			case 'M':	          continue;
			case 'N':	          continue;
			case 'O':	          continue;
			case 'P':	          continue;
			case 'Q':	          continue;
			case 'R':	          continue;
			case 'S':	          continue;
			case 'T':	          continue;
			case 'U':	          continue;
			case 'V':	          continue;
			case 'W':	          continue;
			case 'X':	          continue;
			case 'Y':	          continue;
			case 'Z':	          continue;
			case 'a':	          continue;
			case 'b':	          continue;
			case 'c':	          continue;
			case 'd':	          continue;
			case 'e':	          continue;
			case 'f':	          continue;
			case 'g':	          continue;
			case 'h':	          continue;
			case 'i':	          continue;
			case 'j':	          continue;
			case 'k':	          continue;
			case 'l':	          continue;
			case 'm':	          continue;
			case 'n':	          continue;
			case 'o':	          continue;
			case 'p':	          continue;
			case 'q':	          continue;
			case 'r':	          continue;
			case 's':	          continue;
			case 't':	          continue;
			case 'u':	          continue;
			case 'v':	          continue;
			case 'w':	          continue;
			case 'x':	          continue;
			case 'y':	          continue;
			case 'z':	          continue;
			default:  lx_abnf_ungetc(lx, c); return TOK_IDENT;
			}

		case S36: /* start */
			switch (c) {
			case '\t': state = S22;      continue;
			case '\n': state = S21;      continue;
			case '\v': state = S22;      continue;
			case '\f': state = S22;      continue;
			case '\r': state = S22;      continue;
			case ' ': state = S22;      continue;
			case '\"': state = S23;      continue;
			case '%': state = S24;      continue;
			case '(': state = S25;      continue;
			case ')': state = S26;      continue;
			case '*': state = S27;      continue;
			case '/': state = S28;      continue;
			case '0': state = S29;      continue;
			case '1': state = S29;      continue;
			case '2': state = S29;      continue;
			case '3': state = S29;      continue;
			case '4': state = S29;      continue;
			case '5': state = S29;      continue;
			case '6': state = S29;      continue;
			case '7': state = S29;      continue;
			case '8': state = S29;      continue;
			case '9': state = S29;      continue;
			case ';': state = S30;      continue;
			case '<': state = S31;      continue;
			case '=': state = S32;      continue;
			case 'A': state = S35;      continue;
			case 'B': state = S35;      continue;
			case 'C': state = S35;      continue;
			case 'D': state = S35;      continue;
			case 'E': state = S35;      continue;
			case 'F': state = S35;      continue;
			case 'G': state = S35;      continue;
			case 'H': state = S35;      continue;
			case 'I': state = S35;      continue;
			case 'J': state = S35;      continue;
			case 'K': state = S35;      continue;
			case 'L': state = S35;      continue;
			case 'M': state = S35;      continue;
			case 'N': state = S35;      continue;
			case 'O': state = S35;      continue;
			case 'P': state = S35;      continue;
			case 'Q': state = S35;      continue;
			case 'R': state = S35;      continue;
			case 'S': state = S35;      continue;
			case 'T': state = S35;      continue;
			case 'U': state = S35;      continue;
			case 'V': state = S35;      continue;
			case 'W': state = S35;      continue;
			case 'X': state = S35;      continue;
			case 'Y': state = S35;      continue;
			case 'Z': state = S35;      continue;
			case '[': state = S33;      continue;
			case ']': state = S34;      continue;
			case 'a': state = S35;      continue;
			case 'b': state = S35;      continue;
			case 'c': state = S35;      continue;
			case 'd': state = S35;      continue;
			case 'e': state = S35;      continue;
			case 'f': state = S35;      continue;
			case 'g': state = S35;      continue;
			case 'h': state = S35;      continue;
			case 'i': state = S35;      continue;
			case 'j': state = S35;      continue;
			case 'k': state = S35;      continue;
			case 'l': state = S35;      continue;
			case 'm': state = S35;      continue;
			case 'n': state = S35;      continue;
			case 'o': state = S35;      continue;
			case 'p': state = S35;      continue;
			case 'q': state = S35;      continue;
			case 'r': state = S35;      continue;
			case 's': state = S35;      continue;
			case 't': state = S35;      continue;
			case 'u': state = S35;      continue;
			case 'v': state = S35;      continue;
			case 'w': state = S35;      continue;
			case 'x': state = S35;      continue;
			case 'y': state = S35;      continue;
			case 'z': state = S35;      continue;
			default:  lx->lgetc = NULL; return TOK_UNKNOWN;
			}
		}
	}

	lx->lgetc = NULL;

	switch (state) {
	case S1: return TOK_ALTINC;
	case S2: return TOK_BINSTR;
	case S3: return TOK_BINRANGE;
	case S6: return TOK_BINSTR;
	case S7: return TOK_DECSTR;
	case S8: return TOK_DECRANGE;
	case S11: return TOK_DECSTR;
	case S12: return TOK_HEXSTR;
	case S13: return TOK_HEXRANGE;
	case S16: return TOK_HEXSTR;
	case S20: return TOK_SEP;
	case S21: return TOK_EOF;
	case S22: return TOK_EOF;
	case S23: return TOK_EOF;
	case S25: return TOK_STARTGROUP;
	case S26: return TOK_ENDGROUP;
	case S27: return TOK_REP;
	case S28: return TOK_ALT;
	case S29: return TOK_COUNT;
	case S30: return TOK_EOF;
	case S31: return TOK_EOF;
	case S32: return TOK_EQUALS;
	case S33: return TOK_STARTOPT;
	case S34: return TOK_ENDOPT;
	case S35: return TOK_IDENT;
	default: errno = EINVAL; return TOK_ERROR;
	}
}

const char *
lx_abnf_name(enum lx_abnf_token t)
{
	switch (t) {
	case TOK_ENDOPT: return "ENDOPT";
	case TOK_STARTOPT: return "STARTOPT";
	case TOK_COUNT: return "COUNT";
	case TOK_REP: return "REP";
	case TOK_ENDGROUP: return "ENDGROUP";
	case TOK_STARTGROUP: return "STARTGROUP";
	case TOK_ALTINC: return "ALTINC";
	case TOK_ALT: return "ALT";
	case TOK_LITERAL: return "LITERAL";
	case TOK_HEXRANGE: return "HEXRANGE";
	case TOK_DECRANGE: return "DECRANGE";
	case TOK_BINRANGE: return "BINRANGE";
	case TOK_HEXSTR: return "HEXSTR";
	case TOK_DECSTR: return "DECSTR";
	case TOK_BINSTR: return "BINSTR";
	case TOK_EQUALS: return "EQUALS";
	case TOK_SEP: return "SEP";
	case TOK_NAME: return "NAME";
	case TOK_CHAR: return "CHAR";
	case TOK_IDENT: return "IDENT";
	case TOK_EOF:     return "EOF";
	case TOK_ERROR:   return "ERROR";
	case TOK_UNKNOWN: return "UNKNOWN";
	default: return "?";
	}
}

const char *
lx_abnf_example(enum lx_abnf_token (*z)(struct lx_abnf_lx *), enum lx_abnf_token t)
{
	assert(z != NULL);

	if (z == z1) {
		switch (t) {
		case TOK_LITERAL: return "\"";
		case TOK_CHAR: return "a";
		default: goto error;
		}
	} else
	if (z == z2) {
		switch (t) {
		case TOK_NAME: return ">";
		case TOK_CHAR: return "a";
		default: goto error;
		}
	} else
	if (z == z3) {
		switch (t) {
		default: goto error;
		}
	} else
	if (z == z4) {
		switch (t) {
		case TOK_ENDOPT: return "]";
		case TOK_STARTOPT: return "[";
		case TOK_COUNT: return "0";
		case TOK_REP: return "*";
		case TOK_ENDGROUP: return ")";
		case TOK_STARTGROUP: return "(";
		case TOK_ALTINC: return "=/";
		case TOK_ALT: return "/";
		case TOK_HEXRANGE: return "%xa-a";
		case TOK_DECRANGE: return "%d0-0";
		case TOK_BINRANGE: return "%b0-0";
		case TOK_HEXSTR: return "%xa";
		case TOK_DECSTR: return "%d0";
		case TOK_BINSTR: return "%b0";
		case TOK_EQUALS: return "=";
		case TOK_SEP: return "\x0a\x0a";
		case TOK_IDENT: return "a";
		default: goto error;
		}
	}

error:

	errno = EINVAL;
	return NULL;
}

void
lx_abnf_init(struct lx_abnf_lx *lx)
{
	static const struct lx_abnf_lx lx_default;

	assert(lx != NULL);

	*lx = lx_default;

	lx->c = EOF;
	lx->z = NULL;

	lx->end.byte = 0;
	lx->end.line = 1;
	lx->end.col  = 1;
}

enum lx_abnf_token
lx_abnf_next(struct lx_abnf_lx *lx)
{
	enum lx_abnf_token t;

	assert(lx != NULL);

	if (lx->lgetc == NULL) {
		return TOK_EOF;
	}

	if (lx->z == NULL) {
		lx->z = z4;
	}

	t = lx->z(lx);

	if (lx->push != NULL) {
		if (-1 == lx->push(lx, '\0')) {
			return TOK_ERROR;
		}
	}

	if (lx->lgetc == NULL && lx->free != NULL) {
		lx->free(lx);
	}

	return t;
}

